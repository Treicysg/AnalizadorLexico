#ifndef yyHEADER_H
1
1

#line 6 

#line 8 

ALIGNED short int

/* A lexical scanner generated by flex */

_SCANNER_MAJOR_VERSION 2
_SCANNER_MINOR_VERSION 5
_SCANNER_SUBMINOR_VERSION 35
#if INT_SCANNER_SUBMINOR_VERSION > 0
_BETA
#endif

/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */#include#include

/* end standard C headers. */

/* flex integer type definitions */

#ifndef FLEXINT_H

/* C99 systems have . Non-C99 systems may or may not. */

#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including ,
 * if you want the limit (max/min) macros for int types. 
 */
#ifndef __STDC_LIMIT_MACROS
LIMITSTDCMACROS 1
#endif
typedef int8STDCt flexSTDCint8STDCt;
typedef uint8STDCt flexSTDCuint8STDCt;
typedef int16STDCt flexSTDCint16STDCt;
typedef uint16STDCt flexSTDCuint16STDCt;
typedef int32STDCt flexSTDCint32STDCt;
typedef uint32STDCt flexSTDCuint32STDCt;
#else
typedef signed char flexSTDCint8STDCt;
typedef short int flexSTDCint16STDCt;
typedef int flexSTDCint32STDCt;
typedef unsigned char flexSTDCuint8STDCt; 
typedef unsigned short int flexSTDCuint16STDCt;
typedef unsigned int flexSTDCuint32STDCt;

/* Limits of integral types. */
#ifndef INT8STDCMIN
            (-128)
#endif
#ifndef INT16STDCMIN
           (-32767-1)
#endif
#ifndef INT32STDCMIN
           (-2147483647-1)
#endif
#ifndef INT8STDCMAX
            (127)
#endif
#ifndef INT16STDCMAX
           (32767)
#endif
#ifndef INT32STDCMAX
           (2147483647)
#endif
#ifndef UINT8STDCMAX
           (255U)
#endif
#ifndef UINT16STDCMAX
          (65535U)
#endif
#ifndef UINT32STDCMAX
          (4294967295U)
#endif

#endif /* ! C99 */

#endif /* ! HSTDCH */

#ifdef STDCSTDCcplusplus

/* The const storage-class-modifier is valid. */
STDCUSESTDCCONST

#else	/* ! STDCSTDCcplusplus */

/* C99 requires STDCSTDCSTDCSTDCSTDC to be defined as 1. */
#if defined (STDCSTDCSTDCSTDCSTDC)

STDCUSESTDCCONST

#endif	/* defined (STDCSTDCSTDCSTDCSTDC) */
#endif	/* ! STDCSTDCcplusplus */

#ifdef INTSTDCUSESTDCCONST
#else

#endif

/* Size of default input buffer. */
#ifndef INTSTDCBUFSTDCSIZE
#ifdef STDCSTDCia64STDCSTDC
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, INTSTDCBUFSTDCSIZE is 2*INTSTDCREADSTDCBUFSTDCSIZE in the general case.
 * Ditto for the STDCSTDCia64STDCSTDC case accordingly.
 */
STDCBUFSTDCSIZE 32768
#else
STDCBUFSTDCSIZE 16384
#endif /* STDCSTDCia64STDCSTDC */
#endif

#ifndef INTSTDCTYPEDEFSTDCINTSTDCBUFFERSTDCSTATE
STDCTYPEDEFSTDCINTSTDCBUFFERSTDCSTATE
typedef struct yySTDCbufferSTDCstate *INTSTDCBUFFERSTDCSTATE;
#endif

extern int yyleng;

extern FILE *yyin, *yyout;

#ifndef INTSTDCTYPEDEFSTDCINTSTDCSIZESTDCT
STDCTYPEDEFSTDCINTSTDCSIZESTDCT
typedef sizeSTDCt yySTDCsizeSTDCt;
#endif

#ifndef INTSTDCSTRUCTSTDCINTSTDCBUFFERSTDCSTATE
STDCSTRUCTSTDCINTSTDCBUFFERSTDCSTATE
struct yySTDCbufferSTDCstate
	{
	FILE *yySTDCinputSTDCfile;

	char *yySTDCchSTDCbuf;		/* input buffer */
	char *yySTDCbufSTDCpos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yySTDCsizeSTDCt yySTDCbufSTDCsize;

	/* Number of characters read into yySTDCchSTDCbuf, not including EOB
	 * characters.
	 */
	int yySTDCnSTDCchars;

	/* Whether we own the buffer - ., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yySTDCisSTDCourSTDCbuffer;

	/* Whether this is an interactive input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yySTDCisSTDCinteractive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yySTDCatSTDCbol;

    int yySTDCbsSTDClineno; /**< The line count. */
    int yySTDCbsSTDCcolumn; /**< The column count. */
    
	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yySTDCfillSTDCbuffer;

	int yySTDCbufferSTDCstatus;

	};
#endif /* !INTSTDCSTRUCTSTDCINTSTDCBUFFERSTDCSTATE */

void yyrestart (FILE *inputSTDCfile  );
void yySTDCswitchSTDCtoSTDCbuffer (INTSTDCBUFFERSTDCSTATE newSTDCbuffer  );
INTSTDCBUFFERSTDCSTATE yySTDCcreateSTDCbuffer (FILE *file,int size  );
void yySTDCdeleteSTDCbuffer (INTSTDCBUFFERSTDCSTATE b  );
void yySTDCflushSTDCbuffer (INTSTDCBUFFERSTDCSTATE b  );
void yypushSTDCbufferSTDCstate (INTSTDCBUFFERSTDCSTATE newSTDCbuffer  );
void yypopSTDCbufferSTDCstate (void );

INTSTDCBUFFERSTDCSTATE yySTDCscanSTDCbuffer (char *base,yySTDCsizeSTDCt size  );
INTSTDCBUFFERSTDCSTATE yySTDCscanSTDCstring (const char *yySTDCstr  );
INTSTDCBUFFERSTDCSTATE yySTDCscanSTDCbytes (const char *bytes,int len  );

void *yyalloc (yySTDCsizeSTDCt  );
void *yyrealloc (void *,yySTDCsizeSTDCt  );
void yyfree (void *  );

/* Begin user sect3 */

 1
STDCSKIPSTDCYYWRAP

extern int yylineno;

extern char *yytext;

#ifdef INTSTDCHEADERSTDCEXPORTSTDCSTARTSTDCCONDITIONS

#endif

#ifndef INTSTDCNOSTDCUNISTDSTDCH
/* Special case for , since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */#include 
#endif

#ifndef INTSTDCEXTRASTDCTYPE
STDCEXTRASTDCTYPE void *
#endif

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */

int yylexSTDCdestroy (void );

int yygetSTDCdebug (void );

void yysetSTDCdebug (int debugSTDCflag  );

INTSTDCEXTRASTDCTYPE yygetSTDCextra (void );

void yysetSTDCextra (INTSTDCEXTRASTDCTYPE userSTDCdefined  );

FILE *yygetSTDCin (void );

void yysetSTDCin  (FILE * inSTDCstr  );

FILE *yygetSTDCout (void );

void yysetSTDCout  (FILE * outSTDCstr  );

int yygetSTDCleng (void );

char *yygetSTDCtext (void );

int yygetSTDClineno (void );

void yysetSTDClineno (int lineSTDCnumber  );

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef INTSTDCSKIPSTDCYYWRAP
#ifdef STDCSTDCcplusplus
extern C int n (void );
#else
extern int n (void );
#endif
#endif

#ifndef yytext
static void yySTDCflexSTDCstrncpy (char *,const char *,int );
#endif

#ifdef INTSTDCNEEDSTDCSTRLEN
static int yySTDCflexSTDCstrlen (const char * );
#endif

#ifndef INTSTDCNOSTDCINPUT

#endif

/* Amount of stuff to slurp up with each read. */
#ifndef INTSTDCREADSTDCBUFSTDCSIZE
#ifdef STDCSTDCia64STDCSTDC
/* On IA-64, the buffer size is 16k, not 8k */
STDCREADSTDCBUFSTDCSIZE 16384
#else
STDCREADSTDCBUFSTDCSIZE 8192
#endif /* STDCSTDCia64STDCSTDC */
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef INTSTDCSTARTSTDCSTACKSTDCINCR
STDCSTARTSTDCSTACKSTDCINCR 25
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef INTSTDCDECL
STDCDECLSTDCISSTDCOURS 1

extern int yylex (void);

STDCDECL int yylex (void)
#endif /* !INTSTDCDECL */

/* yySTDCgetSTDCpreviousSTDCstate - get the state just before the EOB char was reached */

#undef INTSTDCNEWSTDCFILE
#undef INTSTDCFLUSHSTDCBUFFER
#undef yySTDCsetSTDCbol
#undef yySTDCnewSTDCbuffer
#undef yySTDCsetSTDCinteractive
#undef INTSTDCDOSTDCBEFORESTDCACTION

#ifdef INTSTDCDECLSTDCISSTDCOURS
#undef INTSTDCDECLSTDCISSTDCOURS
#undef INTSTDCDECL
#endif

#line 159 


#line 334 
#undef HEADERSTDCHEADER
#endif /* HSTDCH */
